---
title: "Part 2 - Nanopore reads"
author: "Jörg Wennmann"
date: "2024-12-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Required libraries

```{r}
library(data.table)
library(ggplot2)
```

# VCF to Matrix transformation

```{r}
# Funktionen definieren
split_string_to_chars <- function(input_string) {
  strsplit(input_string, "")[[1]]
}

process_plus_minus_in_vector <- function(char_vector) {
  i <- 1
  processed_vector <- c()
  
  while (i <= length(char_vector)) {
    if (char_vector[i] %in% c("+", "-")) {
      if ((i + 1) <= length(char_vector) && grepl("^[0-9]+$", char_vector[i + 1])) {
        num <- as.numeric(char_vector[i + 1])
        i <- i + 1 + num
      } else {
        processed_vector <- c(processed_vector, char_vector[i])
      }
    } else {
      processed_vector <- c(processed_vector, char_vector[i])
    }
    i <- i + 1
  }
  processed_vector
}

replace_asterisk_and_hash <- function(char_vector) {
  gsub("\\*|#", "-", char_vector)
}

remove_caret_and_next <- function(char_vector) {
  i <- 1
  result <- c()
  while (i <= length(char_vector)) {
    if (char_vector[i] == "^") {
      i <- i + 2
    } else {
      result <- c(result, char_vector[i])
      i <- i + 1
    }
  }
  result
}

remove_dollar_sign <- function(char_vector) {
  char_vector[char_vector != "$"]
}

create_alignment_matrix <- function(positions, 
                                    base_lists, 
                                    readnames_lists, 
                                    repeated_reads, 
                                    remove_repeated_reads = FALSE) {
  # Extrahiere alle einzigartigen Readnamen
  all_readnames <- unique(unlist(readnames_lists))
  
  # Optional: Entferne mehrfach vorkommende Reads
  if (remove_repeated_reads) {
    all_readnames <- setdiff(all_readnames, repeated_reads)
  }
  
  # Initialisiere die Matrix mit NAs
  alignment_matrix <- matrix(NA, nrow = length(all_readnames), ncol = length(positions),
                             dimnames = list(all_readnames, positions))
  
  # Fülle die Matrix mit den Baseninformationen
  for (i in seq_along(positions)) {
    position <- positions[i]
    base_info <- base_lists[[i]]
    readnames <- readnames_lists[[i]]
    
    for (j in seq_along(readnames)) {
      if (!remove_repeated_reads || !(readnames[j] %in% repeated_reads)) {
        alignment_matrix[readnames[j], as.character(position)] <- base_info[j]
      }
    }
  }
  # Ersetze NA-Werte durch Leerzeichen
  alignment_matrix[is.na(alignment_matrix)] <- ""
  
  return(alignment_matrix)
}

adjust_matrix_with_reference <- function(matrix, refpos_df) {
  # Iteriere über die Spaltennamen der Matrix
  for (position in colnames(matrix)) {
    # Konvertiere die Position in numerisches Format
    numeric_position <- as.numeric(position)
    
    # Hole das Referenznukleotid für die aktuelle Position
    ref_nucleotide <- refpos_df$REF[refpos_df$POS == numeric_position]
    
    # Überprüfe, ob ein gültiges Referenznukleotid gefunden wurde
    if (length(ref_nucleotide) > 0) {
      # Ersetze "," und "." durch das Referenznukleotid
      matrix[, position][matrix[, position] %in% c(",", ".")] <- ref_nucleotide
    }
  }
  return(matrix)
}

capitalize_bases <- function(matrix) {
  # Iteriere über alle Zellen der Matrix
  for (i in seq_len(nrow(matrix))) {
    for (j in seq_len(ncol(matrix))) {
      # Hole den aktuellen Wert
      value <- matrix[i, j]
      # Wenn der Wert kleinbuchstabig ist, konvertiere ihn zu Großbuchstaben
      if (value %in% c("a", "t", "g", "c")) {
        matrix[i, j] <- toupper(value)
      }
    }
  }
  return(matrix)
}

# Hauptprozess------------------------------------------------------------
pileup_data <- fread("pileup/SRR26992682.pileup", sep = "\t", header = FALSE, quote = "", fill = TRUE)
colnames(pileup_data) <- c("Chromosome", "Position", "ReferenceBase", "Coverage", "ReadBases", "Qualities", "noIdea", "ReadNames")


positions <- pileup_data$Position
base_lists <- list()
readnames_lists <- list()
duplicated_read_names <- c()

for (i in seq_len(nrow(pileup_data))) {
  # Verarbeite die Baseninformationen
  base_string <- pileup_data$ReadBases[i]
  char_vector <- split_string_to_chars(base_string)
  result <- process_plus_minus_in_vector(char_vector)
  result <- replace_asterisk_and_hash(result)
  result <- remove_caret_and_next(result)
  result <- remove_dollar_sign(result)
  base_lists[[i]] <- result
  
  # Verarbeite die Readnamen
  readnames <- unlist(strsplit(pileup_data$ReadNames[i], ","))
  readnames_lists[[i]] <- readnames
  
  # Finde doppelte Readnamen und füge sie zum Vektor hinzu
  readname_counts <- table(readnames)
  repeated_reads <- names(readname_counts[readname_counts > 1])
  if (length(repeated_reads) > 0) {
    duplicated_read_names <- unique(c(duplicated_read_names, repeated_reads))
  }
}

# Alignment-Matrix erstellen
result_matrix <- create_alignment_matrix(positions, base_lists, 
                                         readnames_lists, duplicated_read_names, 
                                         remove_repeated_reads = TRUE)

RefPos <- data.frame(REF = pileup_data$ReferenceBase, POS = pileup_data$Position)

# Anwendung der Funktion
adjusted_matrix <- adjust_matrix_with_reference(result_matrix, RefPos)
adjusted_matrix <- capitalize_bases(adjusted_matrix)

dim(adjusted_matrix)
```

# Filter by covered SNP positions

```{r}
# Funktion zum Zählen leerer Felder
fun_empty <- function(x) {
  sum(x == "" | is.na(x))  # Berücksichtigt leere Werte und NA
}

# Funktion zum Zählen von Nicht-Leerwerten
fun_not_empty <- function(x) {
  sum(x != "" & !is.na(x))  # Zählt alle Werte, die nicht leer oder NA sind
}

# Anwenden der Funktionen auf die Zeilen der Matrix
empty <- apply(adjusted_matrix, 1, fun_empty)
not_empty <- apply(adjusted_matrix, 1, fun_not_empty)
#Reads with more than 10 SNPs
positionsCovered <- notEmpty-empty
seqsFiltered1 <- adjusted_matrix[which(positionsCovered >= 10), ]
```

# Filter by second allel frequency

```{r}
getPWM = function( seqs, sym=c("A","C","G","T","-") ) {
	t(apply(seqs,2,function(nuc) {
		idx=which(nuc!="")
		t=table(nuc[idx])
		d=t[sym]
		d[which(is.na(d))]=0
		names(d)=sym;
		return(d/sum(t))
	} ))
}

pwm <- getPWM(seqsFiltered1)

pwm <- t(apply(pwm, 1, sort, decreasing = TRUE))

seqsFiltered2 <- seqsFiltered1[, which(pwm[, 2] >= 0.1)]

head(pwm)
```


```{r}
p <- ggplot() + 
  
  geom_vline(xintercept = 0, linetype='dashed', color='grey') +
  geom_vline(xintercept = 1, linetype='dashed', color='grey') +
  #geom_vline(xintercept = tt, linetype='dashed', color='grey') +
  geom_hline(yintercept = 0, linetype='dashed', color='grey') +
  geom_hline(yintercept = 1, linetype='dashed', color='grey') +
  #geom_hline(yintercept = ecdf_values, linetype='dashed', color='grey') +
  
  
  stat_ecdf(aes(pwm[,4]), col="blue") +
  stat_ecdf(aes(pwm[,3]), col="green") +
  stat_ecdf(aes(pwm[,2]), col="red") +
  stat_ecdf(aes(pwm[,1]), col="black") +

  
  
  theme(axis.text.x = element_text(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = "black"),
          panel.background = element_rect(fill = "white"),
          panel.border = element_rect(colour = "black", fill= NA, linewidth = 1),
          legend.position = "none"
    ) +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  ) +
  xlab("Relative nucleotide frequency") +
  #y = relative cumulative frequency of SNP positions
  ylab("% of SNV positions")

print(p)
```



```{r}
write.table(adjusted_matrix, file = "snp_matrix/result_matrix.txt", sep = " ", 
            col.names = TRUE, row.names = TRUE, quote = FALSE)
```

